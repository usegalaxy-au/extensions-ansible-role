---
- name: Ensure destination directory exists
  ansible.builtin.file:
    path: "{{ galaxy_extensions_dir }}"
    state: directory
    owner: root
    group: root
    mode: '0755'

- name: Collect paths of extensions to install
  ansible.builtin.set_fact:
    extension_paths: >-
      {{ extension_paths | default([]) + [
        role_path + '/templates/extensions/' +
        item.name + '/'
      ] }}
  loop: "{{ galaxy_extensions_enabled }}"
  delegate_to: localhost
  vars:
    ansible_python_interpreter: "{{ ansible_playbook_python }}"

- name: Select appropriate version for each extension based on Galaxy version
  select_extension_versions:
    paths: "{{ extension_paths }}"
    galaxy_version: "{{ galaxy_version }}"
  register: extension_version_paths_result
  delegate_to: localhost
  vars:
    ansible_python_interpreter: "{{ ansible_playbook_python }}"

- name: Extract version paths from module result
  ansible.builtin.set_fact:
    extension_version_paths: "{{ extension_version_paths_result.result }}"

- name: Install each enabled extension
  ansible.builtin.include_tasks: install_extension.yml
  loop: "{{ galaxy_extensions_enabled | zip(extension_version_paths) | list }}"
  loop_control:
    loop_var: extension_item

- name: Collect existing extension directories
  ansible.builtin.command: ls -1 {{ galaxy_extensions_dir }}
  register: existing_extension_dirs
  changed_when: false

- name: Remove old extension directories
  ansible.builtin.file:
    path: "{{ galaxy_extensions_dir }}/{{ item }}"
    state: absent
  with_items: "{{ existing_extension_dirs.stdout_lines }}"
  when: "item not in ((galaxy_extensions_enabled | map(attribute='name') | list) + galaxy_default_extensions)"
  notify: Restart Galaxy
